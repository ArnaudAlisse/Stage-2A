using Plots
using PowerModels
using PowerModelsACDC
using Ipopt
using JuMP
#Pkg.add("Juniper")
using Juniper
using HiGHS
using HiGHS_jll


include("C:\\Users\\33781\\OneDrive\\Documents\\STAGE 2A\\Programmes Julia\\some_functions.jl")
#The idea : We run a TNEP simulations to know which branch should be build. Then we can update "network_data" with the result of this simulation, and finaly run an OPF on "network_data" that has been updated



minlp_solver = JuMP.optimizer_with_attributes(
    Juniper.Optimizer,
    "nl_solver"=>JuMP.optimizer_with_attributes(
        Ipopt.Optimizer,
        "tol"=>1e-4,
        "print_level"=>0,
    ),
    "log_levels"=>[],
)

#Idea : We run a for k = 1:N, so we run N times a simulation in which we modify the initial situation to observe the Evolution of a parameter.
s = Dict("output" => Dict("branch_flows" => true), "conv_losses_mp" => true)
A1 = []
A2 = []
A3 = []
A4 = []
A5 = []


for j=0.2:0.2:3
    local network_data = PowerModels.parse_file("C:\\Users\\33781\\OneDrive\\Documents\\STAGE 2A\\toy.m")
    PowerModelsACDC.process_additional_data!(network_data)
    network_data["load"]["7"]["pd"] = j/2
    network_data["load"]["4"]["pd"] = j/2
    result = PowerModelsACDC.run_acdctnepopf(network_data, DCPPowerModel, minlp_solver; setting = s)

    new_lines = count_new_lines(network_data, result) #this function return the number of branches (AC or DC) that are going to be build
    uptdate_network(network_data, result) #This function define in another file will uptdate the network based on the result of the TNEP. For example, if a DC_branch should be build according to the result of TNEP, then it will be added to the network as an effective branch.

    #So, we built the branchs we wanted to built based on a economic point of view (TNEP). lets optmize their use by doing an OPF.
    resultOPF = run_acdcopf(network_data, DCPPowerModel, minlp_solver; setting = s)

    #index, max_power_line = max_power_line(resultOPF) #for the line with the max power flowing through this function return the index of the line and the power flowing through 

    push!(A1, network_data["load"]["7"]["pd"])
    push!(A2, network_data["load"]["4"]["pd"])
    push!(A3,resultOPF["solution"]["branch"]["2"]["pf"])
    push!(A4,result["objective"])
    push!(A5,resultOPF["objective"])
    println(j)

end

#plot(A1,[A2 A3 A4])
#title!("Evolution of some varialbe in function of a parameter (we need to decide which parameter)")
#xlabel!("The initial value of the parameter")
#ylabel!("The final value of somes variables")

p1 = plot(A1[1:length(A4)], A4, title = "Cost of investment (TNEP) in function of load of bus 7", xlabel = "Initial value of load bus 7 (MW)", ylabel = "Cost (€)")
p2 = plot(A1[1:length(A5)], A5, title = "Cost of functionnement (OPF) in function of load of bus 7", xlabel = "Initial value of load bus 7 (MW)", ylabel = "Cost (€/MWh)")
p3 = plot(A2[1:length(A4)], A4, title = "Cost of investment (TNEP) in function of load of bus 4", xlabel = "Initial value of load bus 4 (MW)", ylabel = "Cost (€)")
p4 = plot(A2[1:length(A5)], A5, title = "Cost of functionnement (OPF) in function of load of bus 4", xlabel = "Initial value of load bus 4 (MW)", ylabel = "Cost (€/MWh)")
plot(p1, p2, p3, p4, layout=(2,2), legend=false)

#Well, we can plot quite anything but I don't really know what I should plot in function of what
