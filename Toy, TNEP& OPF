using PowerModels
using PowerModelsACDC
using Ipopt
using JuMP
#Pkg.add("Juniper")
using Juniper
using HiGHS
using HiGHS_jll


minlp_solver = JuMP.optimizer_with_attributes(
    Juniper.Optimizer,
    "nl_solver"=>JuMP.optimizer_with_attributes(
        Ipopt.Optimizer,
        "tol"=>1e-4,
        "print_level"=>0,
    ),
    "log_levels"=>[],
)
network_data = PowerModels.parse_file("C:\\Users\\33781\\OneDrive\\Documents\\STAGE 2A\\toy.m")

result = solve_tnep(network_data, ACPPowerModel, minlp_solver) #solve_tnep call build_tnep


global b=1
for k = 1:6
       if result["solution"]["ne_branch"]["$k"]["built"] ==1
            println("oui")
            a=6+b
            network_data["branch"]["$a"] = copy(network_data["ne_branch"]["$k"])
            network_data["branch"]["$a"]["rate_b"] = network_data["branch"]["$a"]["rate_a"] 
            network_data["branch"]["$a"]["rate_c"] = network_data["branch"]["$a"]["rate_a"]  
            network_data["branch"]["$a"]["source_id"] = Any["branch", a]  
            network_data["branch"]["$a"]["index"] = a
            delete!(network_data["branch"]["$a"],"construction_cost")
            global b=b+1

            #We added all the terms needed to the good functionnement of "solve_opf"
            #And removed "construction_cost" that wasn't needed.

       end
end

#So, we built the branchs we wanted to built based on a economic point of view (TNEP). lets optmize their use by doing an OPF.
resultOPF = solve_opf(network_data, ACPPowerModel, minlp_solver)


#If this simple model work, I'm gonna try with the DC part.
#So, right now it run.
